package chosen.nlp.lda.test;


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Scanner;
import java.util.Map.Entry;
import java.util.StringTokenizer;

import chosen.nlp.lda.conf.PathConfig;
import chosen.social.lda.util.IDUtil;
import chosen.social.lda.util.Link;
import chosen.social.lda.util.TwitterIDUtil;

public class FilterDocTest {
	
	public static double ration = 0;
	public static int filterBehind = 10;  //删除followerMapSize小于10的follower和followee
	private static Scanner scaner;
	
	public static void main(String args []) throws ClassNotFoundException {
		
    // path for save follower & ee doc
    // arg[0] = 1, we use the wb.ds firstly, then the 2nd time arg[1] = 0, we choose the keeptext.txt, which is generated by the above step.
    try {
    	scaner = new Scanner(System.in);
    	System.out.println("split Files into ");
    	ration = scaner.nextDouble();
    	String path;
    	System.out.println("seperator");
    	String seperator = "\t|,";   //分隔符是tab或者逗号
    	
   		//第一次传1， 读wb.ds的内容，生成keepdata.txt, testdata.txt和follower文件夹下的内容。
		//第二次传0， 读取keepdata.txt的内容, 生成followee文件中的内容
    	if(args[0].equals("0"))   
    		path = PathConfig.keepDataPath;
    	else
    		path = PathConfig.twitterUserLinksFile;
      
    	BufferedReader bufferedReader = new BufferedReader(new FileReader(new File(path)));
    	StringBuffer fileData = new StringBuffer();
    	int bufferSize = 1024 * 1024;   //buffersize = 1MB
    	char[] buffer = new char[bufferSize];
    	int numRead = 0;   //numbers of characters read.
    	int count = 0;     //
    	int transferTimes = 0;
    	String lastLine = "";  //append a empty line after the last link.
      
    	try {
    		//success to read buffer from bufferReader, and store the numbers of read links in numRead.
    		while ((numRead = bufferedReader.read(buffer)) != -1) {
    			String readData = String.valueOf(buffer, 0, numRead);
    			readData = readData.replaceAll(seperator, " "); //使用空格替代制表符和逗号
    			fileData.append(readData);
    			if(++transferTimes % 100 == 0 )  //每append一次，一次1M的内容
    				System.out.println( (++transferTimes) + " M block has been loaded in");
    			if (++count >= 1000) {
    				// 每读1000次写一次文档  
    				lastLine = "";
    				writeToDocuments(fileData, lastLine , args[0]);

    				// append not read last line to file
    				fileData = new StringBuffer();
    				fileData.append(lastLine);
    				count = 0;
    				System.gc();
    			}
    		}
    		//写入剩余部分 
    		writeToDocuments(fileData, lastLine, args[0]); 
    	} catch (IOException e) {
    		e.printStackTrace();
    	}
    	bufferedReader.close();
    	} catch (FileNotFoundException e) {
    		e.printStackTrace();
    	} catch (IOException e) {
    		e.printStackTrace();
    	}
	}

	// 将filedata中的数据先存入link中，再从link中分别取出follower和followee加入到follower(e)_Map中
	public static void writeToDocuments(StringBuffer fileData, String lastLine , String arg) throws IOException, ClassNotFoundException {
		Map<Integer, ArrayList<Integer>> follower_Map; //每个人的index对应一个他的关注者index的List
		Map<Integer, ArrayList<Integer>> followee_Map; //每个人的index对应着 关注他的人的index的 List
		ArrayList<Link> links = new ArrayList<Link>();

		//读取keepdata.txt中的内容
		if (arg.equals("0")) {
			IDUtil idUtil = new IDUtil();
			idUtil = idUtil.read();
			TwitterIDUtil.IDToIndexMap = idUtil.IDToIndexMap;
			TwitterIDUtil.indexToIDMap = idUtil.indexToIDMap;
		}
		
		//tokenizedToLinkAndgetLastLine(String dataString, ArrayList<Link> links, char spliter, String lastLine) 
		tokenizedToLinkAndgetLastLine(fileData.toString(), links, ',' ,lastLine);  // ',' is the split, not used here
    
		follower_Map = new HashMap <Integer, ArrayList<Integer>>();
		followee_Map = new HashMap <Integer, ArrayList<Integer>>();
		
		int times = 0;
		//遍历links：ArrayList中的节点
		for(Link twitterLink : links) {
			if(++times % 100000 == 0)
				System.out.println(times + "links ");
			//follower粉丝            followee 关注对象 
			addToLinkListMap(follower_Map, twitterLink.follower, twitterLink.followee);
			addToLinkListMap(followee_Map, twitterLink.followee, twitterLink.follower);
		}
    
		links.clear();
		links = null;
		System.gc();
    
		if (!arg.equals("0")) {
			//integer limit = 200;
			//entrySet(): return a Set view of mappings contained in the Map. It returns a collection view of the map
			//iterator(): return an iterator over the elements in the set.
			//A map entry is in fact a key-value pair.
			//Iterator takes place of Enumeration in Java Collection Framework.
			Iterator<Entry<Integer, ArrayList<Integer>>> it = follower_Map.entrySet().iterator();
			//hasNext(): return true if the iterator has more emelemts.
			while (it.hasNext()) {
				Entry<Integer, ArrayList<Integer>> followerEntry = it.next();
				//getKey(): return the key corresponding to this entry.
				int key = followerEntry.getKey();
				
				//Math.random(): return a double value with a positive sign between 1.0 - 0.0
				double cursor = Math.random() * ration ;
				if (cursor < ration - 1) { //followeeSize < limit || followerSize < limit
					it.remove();
					followee_Map.remove(key);
				}
			}
			
			Iterator<Entry<Integer,ArrayList<Integer>>> eeIterator = followee_Map.entrySet().iterator();
			//remove those followees that are not followers,除去那些没有关注任何人的followee
			while(eeIterator.hasNext()) {
				Entry<Integer, ArrayList<Integer>> followeeEntry = eeIterator.next();
				int key = followeeEntry.getKey();
				if(!follower_Map.containsKey(key)) {
					eeIterator.remove();
				}
			}
			
			// 
			recursiveRemove(filterBehind, follower_Map, followee_Map);
			
			//清除之前跑程序遗留下的txt 
			clearExistDocs(PathConfig.followerPath,PathConfig.followeePath);
      
			// 输出文档 , 注意文档名为id ,实际内容也为id
			// 文档分为两个文件夹 follower 和 followee
			ShuffleListToDocuments(follower_Map, followee_Map, PathConfig.followerPath);
			
			//Map.clear(): clear all the mappings from the map.
			follower_Map.clear();
			follower_Map = null;
			System.gc();
			
			IDUtil idUtil = new IDUtil();
			idUtil.IDToIndexMap = TwitterIDUtil.IDToIndexMap;
			idUtil.indexToIDMap = TwitterIDUtil.indexToIDMap;
			idUtil.write();
			
		} else {
			//第二次写入/followees
			listToDocuments(followee_Map, PathConfig.followeePath);
			followee_Map.clear();	
			followee_Map = null;
			System.gc();
		}
		//listToDocuments(follower_Map, followee_Map, PathConfig.allFollowPathString);
	}

	private static void recursiveRemove (int limit , Map<Integer, ArrayList<Integer>> follower_Map , Map<Integer, ArrayList<Integer>> followee_Map) {
		
		boolean flag = true;
		// used to store a follower's followeeList's size, or number of elements in the followeeList
		int followerSizeMap[] = new int[TwitterIDUtil.getSize()];
		int followeeSizeMap[] = new int[TwitterIDUtil.getSize()];
    
		Iterator<Entry<Integer, ArrayList<Integer>>> it = follower_Map.entrySet().iterator();
		while (it.hasNext()) {
			Entry<Integer, ArrayList<Integer>> followerEntry = it.next();
			int key = followerEntry.getKey();
			int followeeSize = 0;
			//if the follower-key is also in the followee map, update the followeeSizeMap at the same time.
			if (followee_Map.containsKey(key)) {
				//followeeSize is the number of elements in the follower's followeeList.
				followeeSize = followee_Map.get(key).size();
				followeeSizeMap[key] = followeeSize;
			}
			int followerSize = followerEntry.getValue().size();
			followerSizeMap[key] = followerSize;
		}
		while(flag == true) {
			flag = false;
			Iterator<Entry<Integer, ArrayList<Integer>>> it_rm = follower_Map.entrySet().iterator();
			//delete the followeeSize < limit or followerSize < limit 's 
			while (it_rm.hasNext()) {
				Entry<Integer, ArrayList<Integer>> followerEntry = it_rm.next();
				int key = followerEntry.getKey();
				int followeeSize = followeeSizeMap[key];
				int followerSize = followerSizeMap[key];
				if ( followerSize < limit && followeeSize < limit ) { //followeeSize < limit || followerSize < limit
					it_rm.remove();
					followeeSizeMap[key] = 0;
					followerSizeMap[key] = 0;
					if(followee_Map.containsKey(key)) 
						for(int erId : followee_Map.get(key)) {
							followerSizeMap[erId]--;
						}
					followee_Map.remove(key);
					flag = true;
				}
			}
		}
	}
  
	private static void clearExistDocs(String followerPath, String followeePath) {
		File followerdir = new File(followerPath);
		File followeedir = new File (followeePath);
		//File.listFiles(): returns an array of abstract pathnames denoting the files 
		//in the directory denoted by this abstract name.
		for(File file: followerdir.listFiles()) file.delete();
		for(File file: followeedir.listFiles()) file.delete();
	}

	public static void ShuffleListToDocuments(
			Map<Integer, ArrayList<Integer>> follower_Map, 
			Map<Integer, ArrayList<Integer>> followee_Map, 
			String path) throws IOException 
	{
		BufferedWriter bufferedWriter = null;
		//configure test dataset's file path.
		String testDataPath = PathConfig.testDataPath;
		BufferedWriter testDataBufferedWriter = new BufferedWriter(new FileWriter(testDataPath));
		//keepDataSet is the train dataset.
		BufferedWriter keepDataBufferedWriter = new BufferedWriter(new FileWriter(PathConfig.keepDataPath));
		
		int times = 0 ;
		
		//follower's index --> followee's index list.(an element)
		for(Map.Entry<Integer, ArrayList<Integer>> followEntry : follower_Map.entrySet()) {
			if(++times % 10000 == 0)
				System.out.println(times + "links ok.");
			//path + 'follower's ID.txt', not follower's index.
			String filePath = path + Link.getLinkeeVaule(followEntry.getKey()) + ".txt";
			//Constructs a FileWriter object given a file name :  filePath
			//with a boolean indicating whether or not to append the data written.: ture means append the data written.
			bufferedWriter =new BufferedWriter(new FileWriter(filePath, true) );
			//shuffle , make down split point ,save to a different doc.
			ArrayList<Integer> shuffleList = followEntry.getValue();
			//Collections.shuffle(): Randomly permute the specified list using a default source of randomness.
			Collections.shuffle(shuffleList);
			int crossOverRemark = shuffleList.size() / 10;  //leave 10% for test dataset.
			//int crossOverRemark = 0;
			for(int i = 0 ; i < crossOverRemark ; i++) {
				Integer index = shuffleList.get(i);
				if(followee_Map.containsKey(index))
					//content format: 'followerID followeeID\n'
					testDataBufferedWriter.append(Link.getLinkeeVaule(followEntry.getKey()) + " " + Link.getLinkeeVaule(index) + "\n");
			}
			
			//write the rest 90% to train dataset
			for (int i = crossOverRemark; i < shuffleList.size(); i++) {
				Integer index = shuffleList.get(i);
				if(followee_Map.containsKey(index)) {
					//write every entry to *.txt in /follower(e)s
					bufferedWriter.append(Link.getLinkeeVaule(index) + " ");
					//write to testdata.txt
					keepDataBufferedWriter.append(Link.getLinkeeVaule(followEntry.getKey()) + " " + Link.getLinkeeVaule(index) + "\n");
				}
			}
			bufferedWriter.close();
		}
		testDataBufferedWriter.close();
		keepDataBufferedWriter.close();
	}

	public static void listToDocuments(Map<Integer, ArrayList<Integer>> followee_Map, String path) throws IOException {
		
		BufferedWriter bufferedWriter = null;
		int times = 0 ;
		for(Map.Entry<Integer, ArrayList<Integer> > followEntry : followee_Map.entrySet()) {
			if(++times % 10000 == 0) {
				System.out.println(times + "links ok.");
			}
      
			String filePath = path + Link.getLinkeeVaule(followEntry.getKey()) + ".txt";
			bufferedWriter =new BufferedWriter(new FileWriter(filePath, true) );
			//shuffle , make down split point ,save to a different doc.
			ArrayList<Integer> followValueList = followEntry.getValue();
     
			for (int i = 0 ; i < followValueList.size(); i++) {
				Integer index = followValueList.get(i);
				bufferedWriter.append(Link.getLinkeeVaule(index) + " ");
			}
			bufferedWriter.close();
		}
	}
  
	public static void listToDocuments(
			Map<Integer, ArrayList<Integer>> follower_Map, 
  			Map<Integer, ArrayList<Integer>> followee_Map,String path) {
		
		BufferedWriter bufferedWriter = null;
  		int times = 0 ;
  		for(Map.Entry<Integer, ArrayList<Integer> > followEntry : follower_Map.entrySet()) {
  			if(++times % 10000 == 0) {
  				System.out.println(times + "links ok.");
  			}
  				
  			try {
  				String filePath = path + Link.getLinkeeVaule(followEntry.getKey()) + ".txt";
  				bufferedWriter =new BufferedWriter(new FileWriter(filePath, true) );
  					
  				//listToDocuments
  				HashSet<Integer> unionSet = new HashSet<Integer>();
  				//Adds all of the elements in the specified collection to this collection
  				unionSet.addAll(followEntry.getValue());
  				if(followee_Map.containsKey(followEntry.getKey())){
  					ArrayList<Integer> followeeList= followee_Map.get(followEntry.getKey());
  					unionSet.addAll(followeeList);
  				}
        
  				for(Integer index : unionSet) {
  					bufferedWriter.append(Link.getLinkeeVaule(index) + " ");
  				}
  				bufferedWriter.close();
        
  			} catch (IOException e) {
  				// exception handling left as an exercise for the reader
  			}
  		}
  	}

  	
  	public static void addToLinkListMap(Map<Integer, ArrayList<Integer>> follow_Map, int executor, int target) {
  		ArrayList<Integer> followList;
  		if (!follow_Map.containsKey(executor) ) {
  			followList = new ArrayList<Integer>();
  			followList.add(target);
  			follow_Map.put(executor, followList);
  		} else {
  			followList = follow_Map.get(executor);
  			followList.add(target);
  		}
  	}

  	public static void tokenizedToLinkAndgetLastLine(String dataString, ArrayList<Link> links, char spliter, String lastLine) {
	  	//StringTokenizer allow break a string into tokens.
		StringTokenizer strTok = new StringTokenizer(dataString);
		while (strTok.hasMoreTokens()) {
			String token_follower = strTok.nextToken();
			if( strTok.hasMoreTokens() ) {
			  String token_followee = strTok.nextToken();
			  links.add( new Link(token_follower,token_followee) );
			} else {
			  //get the last line 
			  lastLine = token_follower;
			}
		}
		
		if (lastLine.length() > 0) {
			//get the last line
			Link link = links.get(links.size()-1);
			lastLine = Link.getLinkeeVaule(link.follower) +" "+Link.getLinkeeVaule(link.follower);
			links.remove(links.size()-1);
		}
	}
  
}
